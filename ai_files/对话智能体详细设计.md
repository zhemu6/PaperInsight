# PaperInsight å¯¹è¯æ™ºèƒ½ä½“è¯¦ç»†è®¾è®¡

> **æ–‡æ¡£ç›®çš„**: è¯¦ç»†è®¾è®¡è®ºæ–‡å¯¹è¯æ™ºèƒ½ä½“çš„å®ç°æ–¹æ¡ˆ  
> **æ–‡æ¡£æ—¶é—´**: 2026-01-25  
> **åŸºäº**: AgentScope Java æ¡†æ¶ + å®˜æ–¹ç¤ºä¾‹

---

## ğŸ“‹ ç›®å½•

1. [åŠŸèƒ½æ¦‚è¿°](#åŠŸèƒ½æ¦‚è¿°)
2. [æ¶æ„è®¾è®¡](#æ¶æ„è®¾è®¡)
3. [æ•°æ®åº“è®¾è®¡](#æ•°æ®åº“è®¾è®¡)
4. [æ™ºèƒ½ä½“å®ç°](#æ™ºèƒ½ä½“å®ç°)
5. [å·¥å…·å®ç°](#å·¥å…·å®ç°)
6. [API è®¾è®¡](#api-è®¾è®¡)
7. [å‰ç«¯é›†æˆ](#å‰ç«¯é›†æˆ)
8. [ä¼šè¯ç®¡ç†](#ä¼šè¯ç®¡ç†)

---

## åŠŸèƒ½æ¦‚è¿°

### æ ¸å¿ƒåŠŸèƒ½

**ChatAgentï¼ˆè®ºæ–‡å¯¹è¯æ™ºèƒ½ä½“ï¼‰** å…è®¸ç”¨æˆ·ä¸è®ºæ–‡è¿›è¡Œæ™ºèƒ½å¯¹è¯ï¼Œå®ç°ï¼š

1. **æ™ºèƒ½é—®ç­”**: å›ç­”ç”¨æˆ·å…³äºè®ºæ–‡çš„å„ç§é—®é¢˜
2. **æ·±åº¦è§£æ**: å¯¹è®ºæ–‡çš„ç‰¹å®šéƒ¨åˆ†è¿›è¡Œæ·±å…¥è§£æ
3. **ä¸Šä¸‹æ–‡ç†è§£**: æ”¯æŒå¤šè½®å¯¹è¯ï¼Œä¿æŒä¸Šä¸‹æ–‡
4. **å†…å®¹å¼•ç”¨**: ç²¾ç¡®å¼•ç”¨è®ºæ–‡å†…å®¹ï¼Œæä¾›å¯ä¿¡å›ç­”
5. **æµå¼å“åº”**: å®æ—¶å±•ç¤ºå›ç­”è¿‡ç¨‹ï¼ˆå¯é€‰ï¼‰

### ä½¿ç”¨åœºæ™¯

- ğŸ“„ **è®ºæ–‡è¯¦æƒ…é¡µ**: åœ¨è®ºæ–‡è¯¦æƒ…é¡µæ·»åŠ "æ™ºèƒ½é—®ç­”"åŠŸèƒ½
- ğŸ’¬ **é˜…è¯»åŠ©æ‰‹**: é˜…è¯»è®ºæ–‡æ—¶çš„å®æ—¶é—®ç­”
- ğŸ” **æ·±åº¦ç†è§£**: æ·±å…¥ç†è§£è®ºæ–‡çš„ç‰¹å®šæ¦‚å¿µã€æ–¹æ³•ã€ç»“æœ
- ğŸ“Š **å¯¹æ¯”åˆ†æ**: è¯¢é—®è®ºæ–‡ä¸å…¶ä»–ç ”ç©¶çš„å¯¹æ¯”
- â“ **ç–‘é—®è§£ç­”**: è§£ç­”é˜…è¯»è¿‡ç¨‹ä¸­çš„ç–‘é—®

---

## æ¶æ„è®¾è®¡

### æ•´ä½“æµç¨‹

```
ç”¨æˆ·æé—®
    â†“
åˆ›å»º/åŠ è½½å¯¹è¯ä¼šè¯
    â†“
ChatAgent å¤„ç†
    â”œâ”€â”€ åŠ è½½è®ºæ–‡å†…å®¹ï¼ˆPaperContentToolï¼‰
    â”œâ”€â”€ åŠ è½½åˆ†æç»“æœï¼ˆPaperContentToolï¼‰
    â”œâ”€â”€ æœç´¢ç›¸å…³å†…å®¹ï¼ˆPaperContentToolï¼‰
    â””â”€â”€ åŸºäºä¸Šä¸‹æ–‡å›ç­”
    â†“
ä¿å­˜å¯¹è¯å†å²
    â†“
è¿”å›å›ç­”ï¼ˆæµå¼/éæµå¼ï¼‰
```

### ç»„ä»¶å…³ç³»

```
ChatAgent (åŒ…è£…ç±»)
    â”œâ”€â”€ ReActAgent (æ ¸å¿ƒæ™ºèƒ½ä½“)
    â”œâ”€â”€ PaperContentTool (è®ºæ–‡å†…å®¹å·¥å…·)
    â”œâ”€â”€ AutoContextMemory (è‡ªåŠ¨å‹ç¼©å†…å­˜)
    â””â”€â”€ MysqlSession (ä¼šè¯æŒä¹…åŒ–)
```

---

## æ•°æ®åº“è®¾è®¡

### 1. paper_chat_session (å¯¹è¯ä¼šè¯è¡¨)

```sql
CREATE TABLE IF NOT EXISTS `paper_chat_session` (
    `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT 'ä¸»é”®ID',
    `paper_id` BIGINT NOT NULL COMMENT 'è®ºæ–‡ID',
    `user_id` BIGINT NOT NULL COMMENT 'ç”¨æˆ·ID',
    `session_id` VARCHAR(128) NOT NULL COMMENT 'ä¼šè¯IDï¼ˆpaper_{paperId}_{userId}ï¼‰',
    `title` VARCHAR(256) DEFAULT NULL COMMENT 'ä¼šè¯æ ‡é¢˜ï¼ˆè‡ªåŠ¨ç”Ÿæˆæˆ–ç”¨æˆ·è‡ªå®šä¹‰ï¼‰',
    `message_count` INT DEFAULT 0 COMMENT 'æ¶ˆæ¯æ•°é‡',
    `last_message_time` DATETIME DEFAULT NULL COMMENT 'æœ€åæ¶ˆæ¯æ—¶é—´',
    `create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'åˆ›å»ºæ—¶é—´',
    `update_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT 'æ›´æ–°æ—¶é—´',
    `is_delete` TINYINT NOT NULL DEFAULT '0' COMMENT 'æ˜¯å¦åˆ é™¤',
    PRIMARY KEY (`id`),
    UNIQUE KEY `uk_sessionId` (`session_id`),
    KEY `idx_paperId` (`paper_id`),
    KEY `idx_userId` (`user_id`),
    KEY `idx_lastMessageTime` (`last_message_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='è®ºæ–‡å¯¹è¯ä¼šè¯è¡¨';
```

**è®¾è®¡è¯´æ˜**:
- `session_id`: å”¯ä¸€æ ‡è¯†ï¼Œæ ¼å¼ `paper_{paperId}_{userId}`ï¼Œæ¯ä¸ªç”¨æˆ·å¯¹æ¯ç¯‡è®ºæ–‡æœ‰ä¸€ä¸ªä¼šè¯
- `title`: è‡ªåŠ¨ç”Ÿæˆï¼ˆåŸºäºç¬¬ä¸€ä¸ªé—®é¢˜ï¼‰æˆ–ç”¨æˆ·è‡ªå®šä¹‰
- `message_count`: ç”¨äºç»Ÿè®¡å’Œå±•ç¤º
- `last_message_time`: ç”¨äºæ’åºå’Œæ¸…ç†

### 2. paper_chat_message (å¯¹è¯æ¶ˆæ¯è¡¨)

```sql
CREATE TABLE IF NOT EXISTS `paper_chat_message` (
    `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT 'ä¸»é”®ID',
    `session_id` VARCHAR(128) NOT NULL COMMENT 'ä¼šè¯ID',
    `paper_id` BIGINT NOT NULL COMMENT 'è®ºæ–‡ID',
    `user_id` BIGINT NOT NULL COMMENT 'ç”¨æˆ·ID',
    `role` VARCHAR(20) NOT NULL COMMENT 'è§’è‰²ï¼šuser/assistant',
    `content` TEXT NOT NULL COMMENT 'æ¶ˆæ¯å†…å®¹',
    `content_type` VARCHAR(20) DEFAULT 'text' COMMENT 'å†…å®¹ç±»å‹ï¼štext/markdown',
    `message_index` INT NOT NULL COMMENT 'æ¶ˆæ¯åºå·ï¼ˆä¼šè¯å†…é¡ºåºï¼‰',
    `create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT 'åˆ›å»ºæ—¶é—´',
    `is_delete` TINYINT NOT NULL DEFAULT '0' COMMENT 'æ˜¯å¦åˆ é™¤',
    PRIMARY KEY (`id`),
    KEY `idx_sessionId` (`session_id`),
    KEY `idx_paperId` (`paper_id`),
    KEY `idx_userId` (`user_id`),
    KEY `idx_createTime` (`create_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='è®ºæ–‡å¯¹è¯æ¶ˆæ¯è¡¨';
```

**è®¾è®¡è¯´æ˜**:
- `role`: userï¼ˆç”¨æˆ·æé—®ï¼‰æˆ– assistantï¼ˆæ™ºèƒ½ä½“å›ç­”ï¼‰
- `content_type`: text æˆ– markdownï¼ˆæ”¯æŒ Markdown æ ¼å¼ï¼‰
- `message_index`: ä¼šè¯å†…æ¶ˆæ¯é¡ºåºï¼Œç”¨äºæ¢å¤å¯¹è¯å†å²

---

## æ™ºèƒ½ä½“å®ç°

### 1. ChatAgent åŒ…è£…ç±»

```java
package com.zhemu.paperinsight.agent;

import io.agentscope.core.ReActAgent;
import io.agentscope.core.agent.Event;
import io.agentscope.core.memory.Memory;
import io.agentscope.core.memory.autocontext.AutoContextConfig;
import io.agentscope.core.memory.autocontext.AutoContextMemory;
import io.agentscope.core.message.Msg;
import io.agentscope.core.message.MsgRole;
import io.agentscope.core.message.TextBlock;
import io.agentscope.core.model.Model;
import io.agentscope.core.session.mysql.MysqlSession;
import io.agentscope.core.tool.Toolkit;
import com.zhemu.paperinsight.tools.PaperContentTool;
import com.zhemu.paperinsight.utils.MonitoringHook;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Flux;

import javax.sql.DataSource;

/**
 * è®ºæ–‡å¯¹è¯æ™ºèƒ½ä½“åŒ…è£…ç±»
 * å‚è€ƒå®˜æ–¹ç¤ºä¾‹çš„ SupervisorAgent å®ç°æ–¹å¼
 */
@Component
@Slf4j
@RequiredArgsConstructor
public class ChatAgent {
    
    private final Model model;
    private final PaperContentTool paperContentTool;
    private final String sysPrompt;
    
    @Autowired
    private DataSource dataSource;
    
    /**
     * æµå¼å¯¹è¯å¤„ç†
     * 
     * @param msg ç”¨æˆ·æ¶ˆæ¯
     * @param paperId è®ºæ–‡ID
     * @param userId ç”¨æˆ·ID
     * @return äº‹ä»¶æµ
     */
    public Flux<Event> stream(Msg msg, Long paperId, Long userId) {
        String sessionId = generateSessionId(paperId, userId);
        
        // 1. åˆ›å»ºå·¥å…·é›†
        Toolkit toolkit = new Toolkit();
        toolkit.registerTool(paperContentTool);
        
        // 2. é…ç½®è‡ªåŠ¨ä¸Šä¸‹æ–‡å‹ç¼©
        AutoContextConfig autoContextConfig = AutoContextConfig.builder()
            .tokenRatio(0.4)  // å‹ç¼©åˆ° 40%
            .lastKeep(20)      // ä¿ç•™æœ€å 20 æ¡æ¶ˆæ¯
            .build();
        AutoContextMemory memory = new AutoContextMemory(autoContextConfig, model);
        
        // 3. åˆ›å»º MySQL ä¼šè¯
        MysqlSession mysqlSession = new MysqlSession(
            dataSource, 
            "paper_insight", 
            null, 
            true
        );
        
        // 4. åˆ›å»ºæ™ºèƒ½ä½“
        ReActAgent agent = createAgent(toolkit, memory, paperId);
        
        // 5. åŠ è½½ä¼šè¯å†å²
        agent.loadIfExists(mysqlSession, sessionId);
        
        // 6. æ·»åŠ è®ºæ–‡ä¸Šä¸‹æ–‡ï¼ˆé¦–æ¬¡å¯¹è¯æ—¶ï¼‰
        if (agent.getMemory().getMessages().isEmpty()) {
            addPaperContext(agent, paperId);
        }
        
        // 7. æµå¼å¤„ç†
        return agent.stream(msg)
            .doFinally(signalType -> {
                log.info("Stream terminated with signal: {}, saving session: {}", 
                    signalType, sessionId);
                agent.saveTo(mysqlSession, sessionId);
            });
    }
    
    /**
     * éæµå¼å¯¹è¯å¤„ç†ï¼ˆåŒæ­¥ï¼‰
     */
    public Msg call(Msg msg, Long paperId, Long userId) {
        return stream(msg, paperId, userId)
            .filter(event -> event.isLast())
            .map(Event::getMessage)
            .blockFirst();
    }
    
    /**
     * åˆ›å»º ReActAgent å®ä¾‹
     */
    private ReActAgent createAgent(Toolkit toolkit, Memory memory, Long paperId) {
        // æ„å»ºåŒ…å«è®ºæ–‡IDçš„ç³»ç»Ÿæç¤ºè¯
        String enhancedPrompt = sysPrompt + "\n\nå½“å‰è®ºæ–‡ID: " + paperId;
        
        return ReActAgent.builder()
            .name("paper_chat_agent")
            .sysPrompt(enhancedPrompt)
            .toolkit(toolkit)
            .hook(new MonitoringHook())
            .model(model)
            .memory(memory)
            .maxIterations(10)  // å¯¹è¯å¯èƒ½éœ€è¦å¤šè½®æ¨ç†
            .build();
    }
    
    /**
     * æ·»åŠ è®ºæ–‡ä¸Šä¸‹æ–‡ï¼ˆé¦–æ¬¡å¯¹è¯æ—¶ï¼‰
     */
    private void addPaperContext(ReActAgent agent, Long paperId) {
        try {
            // è·å–è®ºæ–‡åŸºæœ¬ä¿¡æ¯
            String paperInfo = paperContentTool.getPaperInfo(paperId);
            
            // æ·»åŠ åˆ°å†…å­˜ä½œä¸ºç³»ç»Ÿæ¶ˆæ¯
            Msg contextMsg = Msg.builder()
                .role(MsgRole.SYSTEM)
                .content(TextBlock.builder()
                    .text("è®ºæ–‡åŸºæœ¬ä¿¡æ¯ï¼š\n" + paperInfo)
                    .build())
                .build();
            
            agent.getMemory().addMessage(contextMsg);
        } catch (Exception e) {
            log.warn("Failed to add paper context for paperId: {}", paperId, e);
        }
    }
    
    /**
     * ç”Ÿæˆä¼šè¯ID
     */
    private String generateSessionId(Long paperId, Long userId) {
        return String.format("paper_%d_%d", paperId, userId);
    }
}
```

### 2. ChatAgent é…ç½®ç±»

```java
package com.zhemu.paperinsight.config;

import com.zhemu.paperinsight.agent.ChatAgent;
import com.zhemu.paperinsight.tools.PaperContentTool;
import io.agentscope.core.model.Model;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@RequiredArgsConstructor
public class ChatAgentConfig {
    
    private final Model model;
    private final PaperContentTool paperContentTool;
    
    @Value("${agent.prompts.chat-agent-instruction}")
    private String chatAgentInstruction;
    
    @Bean
    public ChatAgent chatAgent() {
        return new ChatAgent(model, paperContentTool, chatAgentInstruction);
    }
}
```

---

## å·¥å…·å®ç°

### PaperContentTool (è®ºæ–‡å†…å®¹å·¥å…·)

```java
package com.zhemu.paperinsight.tools;

import com.zhemu.paperinsight.manager.CosManager;
import com.zhemu.paperinsight.mapper.PaperInfoMapper;
import com.zhemu.paperinsight.mapper.PaperInsightMapper;
import com.zhemu.paperinsight.model.entity.PaperInfo;
import com.zhemu.paperinsight.model.entity.PaperInsight;
import com.zhemu.paperinsight.tools.pdf.PdfExtractionTool;
import io.agentscope.core.tool.Tool;
import io.agentscope.core.tool.ToolParam;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

/**
 * è®ºæ–‡å†…å®¹è®¿é—®å·¥å…·
 * ä¸ºå¯¹è¯æ™ºèƒ½ä½“æä¾›è®ºæ–‡å†…å®¹è®¿é—®èƒ½åŠ›
 */
@Component
@Slf4j
@RequiredArgsConstructor
public class PaperContentTool {
    
    private final PaperInfoMapper paperInfoMapper;
    private final PaperInsightMapper paperInsightMapper;
    private final PdfExtractionTool pdfExtractionTool;
    private final CosManager cosManager;
    
    /**
     * è·å–è®ºæ–‡åŸºæœ¬ä¿¡æ¯
     */
    @Tool(name = "get_paper_info", 
          description = "è·å–è®ºæ–‡åŸºæœ¬ä¿¡æ¯ï¼ˆæ ‡é¢˜ã€ä½œè€…ã€å…³é”®è¯ç­‰ï¼‰")
    public String getPaperInfo(
        @ToolParam(name = "paper_id", description = "è®ºæ–‡ID") Long paperId) {
        try {
            PaperInfo paper = paperInfoMapper.selectById(paperId);
            if (paper == null) {
                return "è®ºæ–‡ä¸å­˜åœ¨ï¼ŒID: " + paperId;
            }
            
            return String.format(
                "è®ºæ–‡æ ‡é¢˜ï¼š%s\n" +
                "ä½œè€…ï¼š%s\n" +
                "å…³é”®è¯ï¼š%s\n" +
                "æ‘˜è¦ï¼š%s\n" +
                "å‘è¡¨æ—¥æœŸï¼š%s",
                paper.getTitle(),
                paper.getAuthors(),
                paper.getKeywords(),
                paper.getAbstractInfo(),
                paper.getPublishDate()
            );
        } catch (Exception e) {
            log.error("Failed to get paper info", e);
            return "è·å–è®ºæ–‡ä¿¡æ¯å¤±è´¥: " + e.getMessage();
        }
    }
    
    /**
     * è·å–è®ºæ–‡å…¨æ–‡å†…å®¹
     */
    @Tool(name = "get_paper_content", 
          description = "è·å–è®ºæ–‡å…¨æ–‡æ–‡æœ¬å†…å®¹")
    public String getPaperContent(
        @ToolParam(name = "paper_id", description = "è®ºæ–‡ID") Long paperId) {
        try {
            PaperInfo paper = paperInfoMapper.selectById(paperId);
            if (paper == null) {
                return "è®ºæ–‡ä¸å­˜åœ¨ï¼ŒID: " + paperId;
            }
            
            // ä» COS æå– PDF æ–‡æœ¬
            String paperText = pdfExtractionTool.extractPdfText(paper.getCosUrl());
            
            if (paperText == null || paperText.isEmpty()) {
                return "è®ºæ–‡å†…å®¹æå–å¤±è´¥";
            }
            
            // é™åˆ¶é•¿åº¦ï¼Œé¿å… token è¿‡å¤š
            int maxLength = 50000;  // çº¦ 5 ä¸‡å­—
            if (paperText.length() > maxLength) {
                paperText = paperText.substring(0, maxLength) + "\n\n[å†…å®¹å·²æˆªæ–­ï¼Œä»…æ˜¾ç¤ºå‰" + maxLength + "å­—ç¬¦]";
            }
            
            return paperText;
        } catch (Exception e) {
            log.error("Failed to get paper content", e);
            return "è·å–è®ºæ–‡å†…å®¹å¤±è´¥: " + e.getMessage();
        }
    }
    
    /**
     * è·å–è®ºæ–‡åˆ†æç»“æœ
     */
    @Tool(name = "get_paper_analysis", 
          description = "è·å–è®ºæ–‡AIåˆ†æç»“æœï¼ˆæ‘˜è¦ã€åˆ›æ–°ç‚¹ã€æ–¹æ³•è®ºã€è¯„åˆ†ï¼‰")
    public String getPaperAnalysis(
        @ToolParam(name = "paper_id", description = "è®ºæ–‡ID") Long paperId) {
        try {
            PaperInsight insight = paperInsightMapper.selectOne(
                new QueryWrapper<PaperInsight>()
                    .eq("paper_id", paperId)
                    .eq("is_delete", 0)
            );
            
            if (insight == null) {
                return "è®ºæ–‡åˆ†æç»“æœä¸å­˜åœ¨ï¼Œè¯·å…ˆè¿›è¡Œè®ºæ–‡åˆ†æ";
            }
            
            return String.format(
                "=== è®ºæ–‡åˆ†æç»“æœ ===\n\n" +
                "ã€æ‘˜è¦ã€‘\n%s\n\n" +
                "ã€åˆ›æ–°ç‚¹ã€‘\n%s\n\n" +
                "ã€æ–¹æ³•è®ºã€‘\n%s\n\n" +
                "ã€è¯„åˆ†ã€‘%d/100\n",
                insight.getSummaryMarkdown(),
                insight.getInnovationPoints(),
                insight.getMethods(),
                insight.getScore()
            );
        } catch (Exception e) {
            log.error("Failed to get paper analysis", e);
            return "è·å–åˆ†æç»“æœå¤±è´¥: " + e.getMessage();
        }
    }
    
    /**
     * æœç´¢è®ºæ–‡ç‰¹å®šç« èŠ‚æˆ–å…³é”®è¯
     */
    @Tool(name = "search_paper_section", 
          description = "åœ¨è®ºæ–‡ä¸­æœç´¢ç‰¹å®šç« èŠ‚æˆ–å…³é”®è¯")
    public String searchPaperSection(
        @ToolParam(name = "paper_id", description = "è®ºæ–‡ID") Long paperId,
        @ToolParam(name = "keyword", description = "æœç´¢å…³é”®è¯æˆ–ç« èŠ‚å") String keyword) {
        try {
            PaperInfo paper = paperInfoMapper.selectById(paperId);
            if (paper == null) {
                return "è®ºæ–‡ä¸å­˜åœ¨ï¼ŒID: " + paperId;
            }
            
            // è·å–è®ºæ–‡å…¨æ–‡
            String paperText = pdfExtractionTool.extractPdfText(paper.getCosUrl());
            if (paperText == null || paperText.isEmpty()) {
                return "è®ºæ–‡å†…å®¹æå–å¤±è´¥";
            }
            
            // ç®€å•æœç´¢ï¼ˆå¯ä»¥ä¼˜åŒ–ä¸ºæ›´æ™ºèƒ½çš„æœç´¢ï¼‰
            String lowerKeyword = keyword.toLowerCase();
            String lowerText = paperText.toLowerCase();
            
            int index = lowerText.indexOf(lowerKeyword);
            if (index == -1) {
                return "æœªæ‰¾åˆ°åŒ…å«å…³é”®è¯çš„å†…å®¹: " + keyword;
            }
            
            // æå–ä¸Šä¸‹æ–‡ï¼ˆå‰åå„ 500 å­—ç¬¦ï¼‰
            int start = Math.max(0, index - 500);
            int end = Math.min(paperText.length(), index + keyword.length() + 500);
            String context = paperText.substring(start, end);
            
            return String.format(
                "æ‰¾åˆ°ç›¸å…³å†…å®¹ï¼ˆå…³é”®è¯ï¼š%sï¼‰ï¼š\n\n%s",
                keyword,
                context
            );
        } catch (Exception e) {
            log.error("Failed to search paper section", e);
            return "æœç´¢å¤±è´¥: " + e.getMessage();
        }
    }
}
```

---

## API è®¾è®¡

### 1. å¯¹è¯æ¥å£

```java
package com.zhemu.paperinsight.controller;

import com.zhemu.paperinsight.agent.ChatAgent;
import com.zhemu.paperinsight.annotation.AuthCheck;
import com.zhemu.paperinsight.common.BaseResponse;
import com.zhemu.paperinsight.common.ResultUtils;
import com.zhemu.paperinsight.model.dto.chat.ChatMessageRequest;
import com.zhemu.paperinsight.model.dto.chat.ChatMessageResponse;
import com.zhemu.paperinsight.model.dto.chat.ChatSessionRequest;
import com.zhemu.paperinsight.model.vo.ChatMessageVO;
import com.zhemu.paperinsight.model.vo.ChatSessionVO;
import com.zhemu.paperinsight.service.ChatService;
import io.agentscope.core.agent.Event;
import io.agentscope.core.message.Msg;
import io.agentscope.core.message.MsgRole;
import io.agentscope.core.message.TextBlock;
import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.http.codec.ServerSentEvent;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Sinks;

import java.util.List;

/**
 * è®ºæ–‡å¯¹è¯æ¥å£
 */
@RestController
@RequestMapping("/chat")
@Slf4j
@RequiredArgsConstructor
public class ChatController {
    
    private final ChatAgent chatAgent;
    private final ChatService chatService;
    
    /**
     * å‘é€æ¶ˆæ¯ï¼ˆæµå¼å“åº”ï¼‰
     */
    @GetMapping(path = "/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    @AuthCheck
    public Flux<ServerSentEvent<String>> streamChat(
        @RequestParam("paper_id") Long paperId,
        @RequestParam("message") String message,
        HttpServletRequest request) {
        
        Long userId = UserContext.getUserId();
        log.info("User {} chatting with paper {}", userId, paperId);
        
        try {
            // æ„å»ºæ¶ˆæ¯
            Msg msg = Msg.builder()
                .role(MsgRole.USER)
                .content(TextBlock.builder().text(message).build())
                .build();
            
            // åˆ›å»ºæµ
            Sinks.Many<ServerSentEvent<String>> sink = 
                Sinks.many().unicast().onBackpressureBuffer();
            
            // å¤„ç†æµ
            processStream(chatAgent.stream(msg, paperId, userId), sink, paperId, userId, message);
            
            return sink.asFlux()
                .doOnCancel(() -> log.info("Client disconnected"))
                .doOnError(e -> log.error("Error occurred", e));
                
        } catch (Exception e) {
            log.error("Failed to process chat", e);
            return Flux.just(
                ServerSentEvent.builder("ç³»ç»Ÿå¤„ç†é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•").build()
            );
        }
    }
    
    /**
     * å‘é€æ¶ˆæ¯ï¼ˆéæµå¼å“åº”ï¼‰
     */
    @PostMapping("/message")
    @AuthCheck
    public BaseResponse<ChatMessageResponse> sendMessage(
        @RequestBody ChatMessageRequest request) {
        
        Long userId = UserContext.getUserId();
        Long paperId = request.getPaperId();
        String message = request.getMessage();
        
        try {
            // ä¿å­˜ç”¨æˆ·æ¶ˆæ¯
            ChatMessageVO userMessage = chatService.saveMessage(
                paperId, userId, "user", message
            );
            
            // è°ƒç”¨æ™ºèƒ½ä½“
            Msg msg = Msg.builder()
                .role(MsgRole.USER)
                .content(TextBlock.builder().text(message).build())
                .build();
            
            Msg response = chatAgent.call(msg, paperId, userId);
            String responseText = extractText(response);
            
            // ä¿å­˜æ™ºèƒ½ä½“å›å¤
            ChatMessageVO assistantMessage = chatService.saveMessage(
                paperId, userId, "assistant", responseText
            );
            
            return ResultUtils.success(ChatMessageResponse.builder()
                .userMessage(userMessage)
                .assistantMessage(assistantMessage)
                .build());
                
        } catch (Exception e) {
            log.error("Failed to send message", e);
            return ResultUtils.error("å‘é€æ¶ˆæ¯å¤±è´¥: " + e.getMessage());
        }
    }
    
    /**
     * è·å–å¯¹è¯å†å²
     */
    @GetMapping("/history")
    @AuthCheck
    public BaseResponse<List<ChatMessageVO>> getHistory(
        @RequestParam("paper_id") Long paperId,
        HttpServletRequest request) {
        
        Long userId = UserContext.getUserId();
        List<ChatMessageVO> messages = chatService.getChatHistory(paperId, userId);
        return ResultUtils.success(messages);
    }
    
    /**
     * è·å–æˆ–åˆ›å»ºä¼šè¯
     */
    @PostMapping("/session")
    @AuthCheck
    public BaseResponse<ChatSessionVO> getOrCreateSession(
        @RequestBody ChatSessionRequest request) {
        
        Long userId = UserContext.getUserId();
        ChatSessionVO session = chatService.getOrCreateSession(
            request.getPaperId(), userId
        );
        return ResultUtils.success(session);
    }
    
    /**
     * åˆ é™¤ä¼šè¯
     */
    @PostMapping("/session/delete")
    @AuthCheck
    public BaseResponse<Boolean> deleteSession(
        @RequestParam("paper_id") Long paperId,
        HttpServletRequest request) {
        
        Long userId = UserContext.getUserId();
        boolean result = chatService.deleteSession(paperId, userId);
        return ResultUtils.success(result);
    }
    
    /**
     * å¤„ç†æµå¼å“åº”
     */
    private void processStream(
        Flux<Event> generator,
        Sinks.Many<ServerSentEvent<String>> sink,
        Long paperId,
        Long userId,
        String userMessage) {
        
        StringBuilder fullResponse = new StringBuilder();
        
        generator
            .doOnNext(event -> log.debug("Event: {}", event))
            .filter(event -> !event.isLast())
            .map(event -> {
                Msg msg = event.getMessage();
                return msg.getContent().stream()
                    .filter(block -> block instanceof TextBlock)
                    .map(block -> ((TextBlock) block).getText())
                    .toList();
            })
            .flatMap(Flux::fromIterable)
            .doOnNext(chunk -> fullResponse.append(chunk))
            .map(content -> ServerSentEvent.builder(content).build())
            .doOnNext(sink::tryEmitNext)
            .doOnError(e -> {
                log.error("Error in stream processing", e);
                sink.tryEmitNext(
                    ServerSentEvent.builder("ç³»ç»Ÿå¤„ç†é”™è¯¯").build()
                );
            })
            .doOnComplete(() -> {
                log.info("Stream processing completed");
                // ä¿å­˜å®Œæ•´å›å¤
                chatService.saveMessage(paperId, userId, "assistant", fullResponse.toString());
                sink.tryEmitComplete();
            })
            .subscribe();
    }
    
    private String extractText(Msg msg) {
        return msg.getContent().stream()
            .filter(block -> block instanceof TextBlock)
            .map(block -> ((TextBlock) block).getText())
            .reduce("", (a, b) -> a + b);
    }
}
```

---

## å‰ç«¯é›†æˆ

### å¯¹è¯ç»„ä»¶è®¾è®¡

```vue
<!-- frontend/src/components/paper/ChatPanel.vue -->
<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { ElMessage } from 'element-plus'
import { streamChat, getChatHistory } from '~/api/chatController'

const props = defineProps<{
  paperId: number
}>()

const messages = ref<ChatMessage[]>([])
const inputMessage = ref('')
const loading = ref(false)
const streaming = ref(false)

// åŠ è½½å†å²æ¶ˆæ¯
const loadHistory = async () => {
  try {
    const res = await getChatHistory({ paperId: props.paperId })
    if (res.code === 0) {
      messages.value = res.data
    }
  } catch (error) {
    ElMessage.error('åŠ è½½å†å²æ¶ˆæ¯å¤±è´¥')
  }
}

// å‘é€æ¶ˆæ¯
const sendMessage = async () => {
  if (!inputMessage.value.trim()) return
  
  // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
  messages.value.push({
    role: 'user',
    content: inputMessage.value,
    timestamp: new Date()
  })
  
  const userMessage = inputMessage.value
  inputMessage.value = ''
  loading.value = true
  streaming.value = true
  
  // æ·»åŠ å ä½ç¬¦æ¶ˆæ¯
  const assistantMessage = {
    role: 'assistant',
    content: '',
    timestamp: new Date()
  }
  messages.value.push(assistantMessage)
  
  try {
    // æµå¼æ¥æ”¶
    const eventSource = new EventSource(
      `/api/chat/stream?paper_id=${props.paperId}&message=${encodeURIComponent(userMessage)}`
    )
    
    eventSource.onmessage = (event) => {
      assistantMessage.content += event.data
    }
    
    eventSource.onerror = () => {
      eventSource.close()
      streaming.value = false
      loading.value = false
    }
    
    eventSource.addEventListener('complete', () => {
      eventSource.close()
      streaming.value = false
      loading.value = false
    })
    
  } catch (error) {
    ElMessage.error('å‘é€æ¶ˆæ¯å¤±è´¥')
    messages.value.pop() // ç§»é™¤å ä½ç¬¦
    loading.value = false
    streaming.value = false
  }
}

onMounted(() => {
  loadHistory()
})
</script>

<template>
  <div class="chat-panel h-full flex flex-col">
    <!-- æ¶ˆæ¯åˆ—è¡¨ -->
    <div class="flex-1 overflow-y-auto p-4 space-y-4">
      <div
        v-for="(msg, index) in messages"
        :key="index"
        :class="['message', msg.role === 'user' ? 'user-message' : 'assistant-message']"
      >
        <div class="message-content" v-html="renderMarkdown(msg.content)"></div>
        <div class="message-time">{{ formatTime(msg.timestamp) }}</div>
      </div>
    </div>
    
    <!-- è¾“å…¥æ¡† -->
    <div class="p-4 border-t">
      <el-input
        v-model="inputMessage"
        type="textarea"
        :rows="3"
        placeholder="è¾“å…¥æ‚¨çš„é—®é¢˜..."
        @keyup.ctrl.enter="sendMessage"
      />
      <div class="mt-2 flex justify-end">
        <el-button
          type="primary"
          :loading="loading"
          :disabled="streaming"
          @click="sendMessage"
        >
          å‘é€ (Ctrl+Enter)
        </el-button>
      </div>
    </div>
  </div>
</template>
```

---

## ä¼šè¯ç®¡ç†

### ChatService å®ç°

```java
package com.zhemu.paperinsight.service;

import com.zhemu.paperinsight.model.vo.ChatMessageVO;
import com.zhemu.paperinsight.model.vo.ChatSessionVO;

import java.util.List;

public interface ChatService {
    
    /**
     * è·å–æˆ–åˆ›å»ºä¼šè¯
     */
    ChatSessionVO getOrCreateSession(Long paperId, Long userId);
    
    /**
     * ä¿å­˜æ¶ˆæ¯
     */
    ChatMessageVO saveMessage(Long paperId, Long userId, String role, String content);
    
    /**
     * è·å–å¯¹è¯å†å²
     */
    List<ChatMessageVO> getChatHistory(Long paperId, Long userId);
    
    /**
     * åˆ é™¤ä¼šè¯
     */
    boolean deleteSession(Long paperId, Long userId);
    
    /**
     * è·å–ç”¨æˆ·çš„æ‰€æœ‰ä¼šè¯
     */
    List<ChatSessionVO> getUserSessions(Long userId);
}
```

---

## é…ç½®ç¤ºä¾‹

### application.yml

```yaml
agent:
  prompts:
    chat-agent-instruction: |
      ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„å­¦æœ¯è®ºæ–‡å¯¹è¯åŠ©æ‰‹ï¼Œä¸“é—¨å¸®åŠ©ç”¨æˆ·æ·±å…¥ç†è§£è®ºæ–‡å†…å®¹ã€‚
      
      ä½ çš„æ ¸å¿ƒèƒ½åŠ›ï¼š
      1. è®ºæ–‡å†…å®¹ç†è§£ï¼šåŸºäºè®ºæ–‡å…¨æ–‡å’Œåˆ†æç»“æœï¼Œå‡†ç¡®ç†è§£è®ºæ–‡å†…å®¹
      2. æ™ºèƒ½é—®ç­”ï¼šå›ç­”ç”¨æˆ·å…³äºè®ºæ–‡çš„å„ç§é—®é¢˜
      3. æ·±åº¦è§£æï¼šå¯¹è®ºæ–‡çš„ç‰¹å®šéƒ¨åˆ†è¿›è¡Œæ·±å…¥è§£æ
      4. å…³è”åˆ†æï¼šå¸®åŠ©ç”¨æˆ·ç†è§£è®ºæ–‡å„éƒ¨åˆ†ä¹‹é—´çš„å…³è”
      
      ä½ å¯ä»¥å›ç­”çš„é—®é¢˜ç±»å‹ï¼š
      - è®ºæ–‡çš„æ ¸å¿ƒè´¡çŒ®æ˜¯ä»€ä¹ˆï¼Ÿ
      - è®ºæ–‡ä½¿ç”¨äº†ä»€ä¹ˆæ–¹æ³•ï¼Ÿ
      - å®éªŒæ˜¯å¦‚ä½•è®¾è®¡çš„ï¼Ÿ
      - è®ºæ–‡çš„åˆ›æ–°ç‚¹åœ¨å“ªé‡Œï¼Ÿ
      - è®ºæ–‡çš„å±€é™æ€§æ˜¯ä»€ä¹ˆï¼Ÿ
      - å¦‚ä½•ç†è§£è®ºæ–‡ä¸­çš„æŸä¸ªæ¦‚å¿µï¼Ÿ
      - è®ºæ–‡ä¸å…¶ä»–ç ”ç©¶çš„å…³ç³»ï¼Ÿ
      - è®ºæ–‡çš„å®é™…åº”ç”¨ä»·å€¼ï¼Ÿ
      
      å·¥ä½œæµç¨‹ï¼š
      1. ç†è§£ç”¨æˆ·é—®é¢˜
      2. ä»è®ºæ–‡å†…å®¹å’Œåˆ†æç»“æœä¸­æ£€ç´¢ç›¸å…³ä¿¡æ¯
      3. ç»“åˆä¸Šä¸‹æ–‡ç»™å‡ºå‡†ç¡®ã€ä¸“ä¸šçš„å›ç­”
      4. å¦‚æœä¿¡æ¯ä¸è¶³ï¼Œè¯šå®å‘ŠçŸ¥å¹¶å¼•å¯¼ç”¨æˆ·
      
      é‡è¦çº¦æŸï¼š
      - åªåŸºäºè®ºæ–‡å†…å®¹å›ç­”ï¼Œä¸è¦ç¼–é€ ä¿¡æ¯
      - å¦‚æœè®ºæ–‡ä¸­æ²¡æœ‰ç›¸å…³ä¿¡æ¯ï¼Œæ˜ç¡®å‘ŠçŸ¥
      - ä¿æŒä¸“ä¸šå’Œå‡†ç¡®
      - ä½¿ç”¨ä¸­æ–‡å›ç­”
      - å¯ä»¥å¼•ç”¨è®ºæ–‡çš„å…·ä½“å†…å®¹ï¼ˆå¦‚"è®ºæ–‡ä¸­æåˆ°..."ï¼‰
      - æ”¯æŒ Markdown æ ¼å¼ï¼Œä¾¿äºå±•ç¤ºä»£ç ã€å…¬å¼ç­‰
```

---

## å®æ–½æ­¥éª¤

### ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€åŠŸèƒ½ï¼ˆ1å‘¨ï¼‰

1. âœ… åˆ›å»ºæ•°æ®åº“è¡¨ï¼ˆpaper_chat_session, paper_chat_messageï¼‰
2. âœ… å®ç° PaperContentTool
3. âœ… å®ç° ChatAgent åŒ…è£…ç±»
4. âœ… å®ç° ChatService
5. âœ… å®ç° ChatControllerï¼ˆéæµå¼ï¼‰

### ç¬¬äºŒé˜¶æ®µï¼šä¼˜åŒ–åŠŸèƒ½ï¼ˆ3-5å¤©ï¼‰

1. âœ… å®ç°æµå¼å“åº”ï¼ˆSSEï¼‰
2. âœ… é›†æˆ MySQL ä¼šè¯ç®¡ç†
3. âœ… å‰ç«¯å¯¹è¯ç»„ä»¶
4. âœ… å¯¹è¯å†å²æŸ¥çœ‹

### ç¬¬ä¸‰é˜¶æ®µï¼šå¢å¼ºåŠŸèƒ½ï¼ˆå¯é€‰ï¼‰

1. âœ… å¯¹è¯å¯¼å‡º
2. âœ… å¯¹è¯æœç´¢
3. âœ… å¤šä¼šè¯ç®¡ç†
4. âœ… å¯¹è¯åˆ†äº«

---

## æ€»ç»“

### æ ¸å¿ƒç‰¹æ€§

- âœ… **æ™ºèƒ½é—®ç­”**: åŸºäºè®ºæ–‡å†…å®¹çš„å‡†ç¡®å›ç­”
- âœ… **å¤šè½®å¯¹è¯**: æ”¯æŒä¸Šä¸‹æ–‡ç†è§£
- âœ… **å†…å®¹å¼•ç”¨**: ç²¾ç¡®å¼•ç”¨è®ºæ–‡å†…å®¹
- âœ… **æµå¼å“åº”**: å®æ—¶å±•ç¤ºå›ç­”è¿‡ç¨‹
- âœ… **ä¼šè¯ç®¡ç†**: MySQL æŒä¹…åŒ–å¯¹è¯å†å²

### æŠ€æœ¯è¦ç‚¹

- å‚è€ƒå®˜æ–¹ç¤ºä¾‹çš„ SupervisorAgent å®ç°æ–¹å¼
- ä½¿ç”¨ AutoContextMemory ä¼˜åŒ–æˆæœ¬
- ä½¿ç”¨ MysqlSession æŒä¹…åŒ–ä¼šè¯
- ä½¿ç”¨ SSE å®ç°æµå¼å“åº”
- å·¥å…·åŒ–è®¿é—®è®ºæ–‡å†…å®¹

---

**æ–‡æ¡£ç»´æŠ¤**: éšç€å¼€å‘è¿›åº¦ï¼ŒæŒç»­æ›´æ–°å®é™…ä½¿ç”¨ä¸­çš„ç»éªŒå’Œé—®é¢˜ã€‚
